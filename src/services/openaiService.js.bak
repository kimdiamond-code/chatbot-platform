// ChatBot Service with OpenAI Integration
// Handles AI responses, knowledge base, and conversation management

// Utility functions
const retryDelay = (attempt) => Math.min(1000 * Math.pow(2, attempt), 10000);

const safeJSONParse = async (response) => {
  try {
    const text = await response.text();
    try {
      return JSON.parse(text);
    } catch (e) {
      console.error('‚ùå JSON Parse Error:', e);
      console.log('üìù Raw response:', text);
      throw new Error(`Invalid JSON response: ${text.substring(0, 100)}...`);
    }
  } catch (e) {
    console.error('‚ùå Response Text Error:', e);
    throw new Error('Failed to read response body');
  }
};

const safeFetch = async (url, options = {}) => {
  try {
    const response = await fetch(url, {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        ...options.headers,
      },
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    return await safeJSONParse(response);
  } catch (error) {
    console.error(`‚ùå Fetch Error (${url}):`, error);
    throw error;
  }
};

// Custom error classes for better error handling
class ChatBotError extends Error {
  constructor(message, code, details = {}) {
    super(message);
    this.name = 'ChatBotError';
    this.code = code;
    this.details = details;
  }
}

class APIError extends ChatBotError {
  constructor(message, details = {}) {
    super(message, 'API_ERROR', details);
    this.name = 'APIError';
  }
}

class ValidationError extends ChatBotError {
  constructor(message, details = {}) {
    super(message, 'VALIDATION_ERROR', details);
    this.name = 'ValidationError';
  }
}

class ChatBotService {
  constructor() {
    this.conversations = new Map(); // Store conversation contexts
    this.knowledgeBase = new Map(); // Store bot knowledge bases
    this.openaiClient = null; // Initialize lazily
    this.maxPromptLength = 4000; // Maximum length for system prompts
    this.maxRetries = 3; // Maximum number of retries for API calls
    constructor() {
    this.conversations = new Map(); // Store conversation contexts
    this.knowledgeBase = new Map(); // Store bot knowledge bases
    this.openaiClient = null; // Initialize lazily
    this.maxPromptLength = 4000; // Maximum length for system prompts
    this.maxRetries = 3; // Maximum number of retries for API calls
    this.defaultSystemPrompt = `You are a helpful customer service assistant for True Citrus. You are professional, friendly, and concise.

You help customers with their questions and try to resolve their issues.

For order tracking and product inquiries:
1. Ask for the customer's email address if not provided
2. Help search for products when customers ask about them
3. Assist with shopping cart operations when needed

Always gather required information in a friendly way:
- For orders: "I'll help you track your order! Could you please provide your email address?"
- For products: "I'll help you find what you're looking for! What type of products are you interested in?"

After getting the required information:
- Use the available integrations to look up order status
- Search product catalog for relevant items
- Help with cart management

Never promise to do something you cannot do. Always ask for necessary information first.`;

    // Initialize error handlers
    this.handleApiError = this.handleApiError.bind(this);
    this.handleConnectionError = this.handleConnectionError.bind(this);
}
    
    // Initialize error handlers
    this.handleApiError = this.handleApiError.bind(this);
    this.handleConnectionError = this.handleConnectionError.bind(this);
  }

  // Sanitize and validate prompt content
  sanitizePrompt(prompt) {
    if (!prompt || typeof prompt !== 'string') {
      console.warn('‚ö†Ô∏è Invalid prompt format, using default');
      return this.defaultSystemPrompt;
    }

    try {
      // Remove any potential JSON-breaking characters
      let sanitized = prompt
        .replace(/[\u0000-\u0008\u000B-\u000C\u000E-\u001F\u007F-\u009F]/g, '') // Remove control characters
        .replace(/\u2028/g, '\\n') // Line separator
        .replace(/\u2029/g, '\\n\\n'); // Paragraph separator

      // Ensure it's valid JSON when wrapped in quotes (basic JSON safety check)
      JSON.parse(`"${sanitized}"`);

      // Truncate if too long
      if (sanitized.length > this.maxPromptLength) {
        sanitized = sanitized.substring(0, this.maxPromptLength - 3) + '...';
      }

      return sanitized;
    } catch (error) {
      console.error('‚ùå Prompt sanitization error:', error);
      return this.defaultSystemPrompt;
    }
  }

  // Sanitize and validate content from knowledge base
  sanitizeContent(content) {
    if (!content || typeof content !== 'string') {
      return null;
    }

    try {
      // Remove potential problematic characters
      let sanitized = content
        .replace(/[\u0000-\u0008\u000B-\u000C\u000E-\u001F\u007F-\u009F]/g, '')
        .replace(/\u2028/g, '\\n')
        .replace(/\u2029/g, '\\n\\n')
        .trim();

      // Basic structure validation
      if (sanitized.length < 1) {
        return null;
      }

      // Ensure it's valid JSON when wrapped (basic safety check)
      JSON.parse(`"${sanitized}"`);

      return sanitized;
    } catch (error) {
      console.error('‚ùå Content sanitization error:', error);
      return null;
    }
  }

  // Check if conversation should be escalated to human
  shouldEscalateToHuman(userMessage, aiResponse) {
    const escalationKeywords = [
      'human', 'agent', 'person', 'representative', 'manager', 
      'speak to someone', 'talk to someone', 'real person',
      'urgent', 'complaint', 'angry', 'frustrated'
    ];

    const errorKeywords = [
      'error', 'not working', 'broken', 'failed', 'incorrect',
      'wrong', 'issue', 'problem', 'bug', 'glitch', 'invalid'
    ];

    const userLower = userMessage.toLowerCase();
    const aiLower = aiResponse?.toLowerCase() || '';
    
    // Check user message for escalation keywords
    const hasEscalationKeyword = escalationKeywords.some(keyword => userLower.includes(keyword));
    
    // Check for error patterns in AI response
    const hasErrorIndication = errorKeywords.some(keyword => aiLower.includes(keyword)) 
      && (aiLower.includes('cannot') || aiLower.includes('unable') || aiLower.includes('failed'));
    
    // Check for repeated user frustration
    const conversation = this.conversations.get(userLower) || { messages: [] };
    const lastMessages = conversation.messages.slice(-4);
    const repeatedFrustration = lastMessages.filter(m => 
      m.role === 'user' && 
      escalationKeywords.some(keyword => m.content.toLowerCase().includes(keyword))
    ).length >= 2;
    
    // Escalate if any conditions are met
    return hasEscalationKeyword || hasErrorIndication || repeatedFrustration;
  }

    }

  // Update bot configuration
  updateBotConfig(conversationId, config) {
    let conversation = this.conversations.get(conversationId) || { messages: [] };
    conversation.systemPrompt = config.systemPrompt || this.defaultSystemPrompt;
    this.conversations.set(conversationId, conversation);
  }
  }

  // FIXED: Proper async initialization of OpenAI client with enhanced error handling
  async getOpenAIClient() {
    try {
      // Check cached client's validity first
      if (this.openaiClient?.isValid) {
        try {
          // Quick validation of cached client
          await this.openaiClient.chat.completions.create({
            model: 'gpt-3.5-turbo',
            messages: [{ role: 'system', content: 'test' }],
            max_tokens: 5
          });
          return this.openaiClient;
        } catch (error) {
          console.log('‚ö†Ô∏è Cached client validation failed, reinitializing...');
          this.openaiClient = null;
        }
      }

      // Get and validate API key from environment
      let apiKey = import.meta.env.VITE_OPENAI_API_KEY;
      
      console.log('üîç OpenAI API Key Check:', {
        hasKey: !!apiKey,
        keyLength: apiKey ? apiKey.length : 0,
        keyPrefix: apiKey ? apiKey.substring(0, 7) + '...' : 'none',
        environment: import.meta.env.MODE,
        productionMode: localStorage.getItem('PRODUCTION_MODE')
      });
      
      if (!apiKey || apiKey === 'your-openai-key' || apiKey === 'demo-mode' || apiKey.trim() === '') {
        console.log('üéÆ Demo Mode: OpenAI API not configured - using fallback responses');
        console.log('üí° To enable OpenAI: Get API key from https://platform.openai.com/api-keys');
        console.log('üí° Expected format: sk-proj-...');
        this.openaiClient = null; // Explicitly cache null to avoid re-attempts
        return null;
      }

      // FIXED: Proper async import with error handling and module structure detection
      console.log('üîÑ Importing OpenAI module...');
      const openaiModule = await import('openai');
      
      // Handle different module export patterns
      let OpenAI;
      if (openaiModule.default) {
        OpenAI = openaiModule.default;
        console.log('üì¶ Using default export from OpenAI module');
      } else if (openaiModule.OpenAI) {
        OpenAI = openaiModule.OpenAI;
        console.log('üì¶ Using named export from OpenAI module');
      } else {
        console.error('OpenAI module structure:', openaiModule);
        throw new Error('OpenAI class not found in module exports. Check console for module structure.');
      }

      // Log configuration details
      console.log('OpenAI Configuration:', {
        apiKeyExists: !!apiKey,
        apiKeyLength: apiKey?.length,
        environment: import.meta.env.MODE,
        moduleType: OpenAI ? 'class' : 'unknown'
      });
      
      // Create and cache the client
      console.log('üîß Creating OpenAI client instance...');
      this.openaiClient = new OpenAI({
        apiKey: apiKey.trim(),
        dangerouslyAllowBrowser: true // Required for client-side usage
      });
      
      // Test the client by checking if it has required methods
      if (typeof this.openaiClient.chat?.completions?.create !== 'function') {
        throw new Error('OpenAI client missing required chat.completions.create method');
      }
      
      console.log('‚úÖ OpenAI client initialized and cached successfully');
      console.log('üöÄ Ready to process AI requests');
      
      return this.openaiClient;
      
    } catch (error) {
      console.error('‚ùå Failed to initialize OpenAI client:', {
        error: error.message,
        stack: error.stack,
        name: error.name
      });
      
      // Cache null to prevent repeated failed attempts
      this.openaiClient = null;
      
      if (error.message.includes('not found')) {
        console.log('‚ö†Ô∏è OpenAI package not installed - install with: npm install openai');
      } else if (error.message.includes('module')) {
        console.log('‚ö†Ô∏è OpenAI module import failed - check package version compatibility');
      }
      
      console.log('üéÆ Using fallback responses until OpenAI is available');
      return null;
    }
  }

  // Set knowledge base for a specific bot/conversation
  setKnowledgeBase(conversationId, knowledgeItems) {
    console.log('üìö Setting knowledge base for conversation:', conversationId);
    console.log('üìö Knowledge items received:', knowledgeItems?.length || 0);
    
    if (knowledgeItems && knowledgeItems.length > 0) {
      // Log each knowledge item to see the structure
      knowledgeItems.forEach((item, index) => {
        console.log(`üìö Knowledge item ${index}:`, {
          name: item.name,
          type: item.type,
          hasContent: !!item.content,
          contentLength: item.content?.length || 0,
          hasChunks: !!item.chunks,
          chunksLength: item.chunks?.length || 0,
          keywords: item.keywords
        });
      });
    }
    
    this.knowledgeBase.set(conversationId, knowledgeItems || []);
    console.log('üìö Knowledge base set successfully');
  }

  // Search knowledge base for relevant information
  searchKnowledgeBase(conversationId, query, maxResults = 3) {
    console.log('üîç Searching knowledge base for:', query);
    
    const knowledge = this.knowledgeBase.get(conversationId);
    console.log('üîç Knowledge base for conversation:', {
      conversationId,
      hasKnowledge: !!knowledge,
      itemCount: knowledge?.length || 0
    });
    
    if (!knowledge || knowledge.length === 0) {
      console.log('‚ö†Ô∏è No knowledge base found for conversation');
      return [];
    }

    const queryLower = query.toLowerCase();
    const queryWords = queryLower.split(/\s+/).filter(word => word.length > 2);
    const results = [];
    
    console.log('üîç Query words:', queryWords);

    // Search through all knowledge items
    for (const item of knowledge) {
      if (!item || !item.enabled) {
        console.log('üôÑ Skipping disabled item:', item?.name);
        continue;
      }
      
      console.log('üîç Processing item:', item.name);

      // Handle chunked content
      if (item.chunks && Array.isArray(item.chunks)) {
        console.log('üîç Item has chunks:', item.chunks.length);
        
        for (let i = 0; i < item.chunks.length; i++) {
          const chunk = item.chunks[i];
          const score = this.calculateRelevanceScore(chunk, queryWords, item.keywords || []);
          
          if (score > 0) {
            console.log('‚úÖ Found relevant chunk with score:', score);
            results.push({
              content: chunk,
              score,
              source: item.name,
              type: item.type,
              chunkIndex: i
            });
          }
        }
      } 
      // Handle full content (not chunked)
      else if (item.content) {
        console.log('üîç Item has full content:', item.content.length, 'characters');
        
        const score = this.calculateRelevanceScore(item.content, queryWords, item.keywords || []);
        
        if (score > 0) {
          console.log('‚úÖ Found relevant content with score:', score);
          
          // Extract relevant snippet from content
          const snippet = this.extractRelevantSnippet(item.content, queryWords);
          
          results.push({
            content: snippet,
            score,
            source: item.name,
            type: item.type,
            chunkIndex: 0
          });
        }
      } else {
        console.log('‚ö†Ô∏è Item has no content or chunks:', item.name);
      }
    }

    // Sort by score and return top results
    const sortedResults = results
      .sort((a, b) => b.score - a.score)
      .slice(0, maxResults);
      
    console.log('üìà Knowledge search results:', {
      totalFound: results.length,
      returned: sortedResults.length,
      topScores: sortedResults.map(r => ({ source: r.source, score: r.score }))
    });
    
    return sortedResults;
  }
  
  // Calculate relevance score for content
  calculateRelevanceScore(content, queryWords, keywords = []) {
    const contentLower = content.toLowerCase();
    let score = 0;

    // Score based on query word matches
    for (const word of queryWords) {
      const matches = (contentLower.match(new RegExp(word, 'g')) || []).length;
      score += matches;
      
      // Bonus for exact phrase matches
      if (matches > 0 && word.length > 4) {
        score += 0.5;
      }
    }

    // Score based on item keywords (higher weight)
    for (const keyword of keywords) {
      const keywordLower = keyword.toLowerCase();
      for (const queryWord of queryWords) {
        if (keywordLower.includes(queryWord) || queryWord.includes(keywordLower)) {
          score += 2;
        }
      }
    }

    // Bonus for multiple query words appearing close together
    const queryPhrase = queryWords.join(' ');
    if (contentLower.includes(queryPhrase)) {
      score += 2;
    }

    return score;
  }
  
  // Extract relevant snippet from content
  extractRelevantSnippet(content, queryWords, snippetLength = 300) {
    const contentLower = content.toLowerCase();
    let bestMatch = { index: 0, score: 0 };

    // Find the position with the highest concentration of query words
    for (let i = 0; i < content.length - snippetLength; i += 50) {
      const snippet = content.substring(i, i + snippetLength).toLowerCase();
      let score = 0;
      
      for (const word of queryWords) {
        score += (snippet.match(new RegExp(word, 'g')) || []).length;
      }
      
      if (score > bestMatch.score) {
        bestMatch = { index: i, score };
      }
    }

    // Extract snippet around the best match
    let start = Math.max(0, bestMatch.index - 50);
    let end = Math.min(content.length, bestMatch.index + snippetLength + 50);
    
    // Try to end at sentence boundaries
    const snippet = content.substring(start, end);
    const sentences = snippet.split(/[.!?]+/);
    
    if (sentences.length > 1) {
      // Remove incomplete first and last sentences
      const completeSentences = sentences.slice(1, -1);
      if (completeSentences.length > 0) {
        return completeSentences.join('. ') + '.';
      }
    }
    
    // Fallback to character-based snippet
    let result = snippet.trim();
    if (start > 0) result = '...' + result;
    if (end < content.length) result = result + '...';
    
    return result;
  }

  // Validate customer data structure
  validateCustomerData(data) {
    try {
      // Ensure data is an object
      if (!data || typeof data !== 'object') {
        return {};
      }

      // Clean and validate each field
      return {
        email: typeof data.email === 'string' ? data.email.trim().toLowerCase() : undefined,
        name: typeof data.name === 'string' ? data.name.trim() : undefined,
        id: typeof data.id === 'string' || typeof data.id === 'number' ? String(data.id) : undefined,
        // Add any other fields that need validation
      };
    } catch (error) {
      console.error('‚ùå Customer data validation error:', error);
      return {};
    }
  }

  // Generate AI response with knowledge base integration and enhanced error handling
  async generateResponse(message, conversationId, botConfig = null) {
    console.log('ü§ñ ChatBotService.generateResponse called:', message);
    console.log('ü§ñ Conversation ID:', conversationId);
    console.log('ü§ñ Bot config available:', !!botConfig);
    console.log('ü§ñ Production mode:', localStorage.getItem('PRODUCTION_MODE'));
    
    // Input validation
    if (!message || typeof message !== 'string') {
      throw new Error('Invalid message format');
    }
    if (!conversationId || typeof conversationId !== 'string') {
      throw new Error('Invalid conversation ID');
    }
    
    try {
      // FIXED: Await the OpenAI client initialization with better error handling
      console.log('üîÑ Attempting to get OpenAI client...');
      const openaiClient = await this.getOpenAIClient();
      
      if (!openaiClient) {
        console.log('‚ö° No OpenAI client available - using enhanced fallback response');
        return this.getFallbackResponse(message, conversationId);
      }
      
      console.log('‚úÖ OpenAI client ready - proceeding with API call...');

      console.log('üöÄ OpenAI client ready - generating AI response...');

      // Search knowledge base for relevant information
      console.log('üìö Starting knowledge base search...');
      const knowledgeResults = this.searchKnowledgeBase(conversationId, message);
      console.log('üìö Knowledge search complete. Results found:', knowledgeResults.length);
      
      // Get or create conversation context
      let conversation = this.conversations.get(conversationId) || {
        messages: [],
        systemPrompt: botConfig?.systemPrompt || this.defaultSystemPrompt
      };

      // Add user message to conversation
      conversation.messages.push({
        role: 'user',
        content: message
      });

      // Prepare and validate system prompt with knowledge base context
      let enhancedSystemPrompt = this.sanitizePrompt(conversation.systemPrompt || this.defaultSystemPrompt);
      
      if (knowledgeResults.length > 0) {
        console.log('‚úÖ Adding knowledge base context to OpenAI prompt');
        enhancedSystemPrompt += `\n\nRELEVANT INFORMATION:\n`;
        
        for (let i = 0; i < knowledgeResults.length; i++) {
          const result = knowledgeResults[i];
          // Sanitize and validate content before adding
          const sanitizedContent = this.sanitizeContent(result.content);
          if (sanitizedContent) {
            enhancedSystemPrompt += `\n${sanitizedContent}\n`;
            console.log(`üìö Added knowledge from: ${result.source} (score: ${result.score})`);
          }
        
        enhancedSystemPrompt += `\nUse the above information naturally to help answer the user's question. Do not mention sources or where the information came from. Respond as if this is your own knowledge.`;
      } else {
        console.log('‚ö†Ô∏è No knowledge base results found, using OpenAI general knowledge only');
      }

      // Prepare messages for OpenAI (include enhanced system prompt)
      const messages = [
        { role: 'system', content: enhancedSystemPrompt },
        ...conversation.messages.slice(-10) // Keep last 10 messages for context
      ];
      
      try {
        // Check if we should handle this with Shopify integration first
        console.log('üõçÔ∏è Checking for Shopify-specific inquiries...');
        const shopifyResponse = await this.checkShopifyIntegration(message, conversationId);
        
        if (shopifyResponse && shopifyResponse.hasShopifyResponse) {
          console.log('‚úÖ Shopify provided specific response:', shopifyResponse.type);
          
          // Add Shopify response to conversation
          conversation.messages.push({
            role: 'assistant',
            content: shopifyResponse.response
          });
          
          this.conversations.set(conversationId, conversation);
          
          return {
            response: shopifyResponse.response,
            confidence: shopifyResponse.confidence || 0.95,
            source: 'shopify',
            knowledgeUsed: false,
            shopifyData: shopifyResponse.data,
            shouldEscalate: false
          };
        }
      } catch (error) {
        console.error('‚ùå Shopify integration error (continuing with OpenAI):', error);
        // Don't fail the whole request - continue with OpenAI
      }
      
      console.log('ü§ñ Calling OpenAI API with enhanced prompt...');
      console.log('ü§ñ System prompt length:', enhancedSystemPrompt.length);
      console.log('ü§ñ Messages to send:', messages.length);

      // FIXED: Call OpenAI API with robust error handling, retries, and JSON validation
      console.log('üì° Making OpenAI API call...');
      let completion;
      let lastError;

      const validateResponse = (response) => {
        if (!response || typeof response !== 'object') {
          throw new Error('Invalid response format');
        }
        if (!response.choices || !Array.isArray(response.choices) || !response.choices[0]) {
          throw new Error('No choices in response');
        }
        if (!response.choices[0].message || !response.choices[0].message.content) {
          throw new Error('No message content in response');
        }
        return response;
      };

      for (let attempt = 0; attempt < this.maxRetries; attempt++) {
        try {
          if (attempt > 0) {
            console.log(`üîÑ Retry attempt ${attempt + 1}/${this.maxRetries}`);
            await new Promise(resolve => setTimeout(resolve, retryDelay(attempt)));
          }

          const startTime = Date.now();
          completion = await openaiClient.chat.completions.create({
            model: 'gpt-3.5-turbo',
            messages: messages,
            max_tokens: 500,
            temperature: 0.7,
            stream: false,
            timeout: 30000 // 30 second timeout
          });

          console.log(`üì° OpenAI API call completed in ${Date.now() - startTime}ms`);
          lastError = null;
          break; // Success - exit retry loop
      } catch (error) {
        console.error('‚ùå OpenAI API error:', {
          name: error.name,
          message: error.message,
          code: error.code,
          type: error.type,
          param: error.param,
          status: error.status
        });
        
        // Check for specific error types and throw appropriate errors
                  if (error.message?.includes('API key')) {
            console.error('‚ùå API key error - retrying may not help');
            lastError = new Error('OpenAI API key invalid or missing');
            break; // Don't retry API key errors
          }
          if (error.message?.includes('timeout') || error.code === 'ETIMEDOUT') {
            console.warn('‚ö†Ô∏è Request timeout - will retry');
            lastError = new Error('OpenAI request timed out');
            continue;
          }
          if (error.status === 429) {
            console.warn('‚ö†Ô∏è Rate limit - will retry with backoff');
            lastError = new Error('OpenAI rate limit exceeded');
            continue;
          }
          if (error.status === 500) {
            console.warn('‚ö†Ô∏è OpenAI service error - will retry');
            lastError = new Error('OpenAI service error');
            continue;
          }
          
          console.error('‚ùå Unexpected error:', error);
          lastError = new Error(`OpenAI API error: ${error.message}`);
          continue;
      }

      console.log('üì° OpenAI API response received successfully');
      if (!completion?.choices?.[0]?.message?.content) {
        throw new Error('Invalid or empty response from OpenAI');
      }

      try {
        // Validate and safely parse the response
        validateResponse(completion);
        const aiResponse = completion.choices[0].message.content;
        
        // Additional JSON safety check
        if (aiResponse) {
          // Try to detect if it's JSON and parse it safely
          try {
            JSON.parse(`"${aiResponse}"`); // Test if it can be safely stringified
          } catch (e) {
            console.warn('‚ö†Ô∏è Response contains invalid JSON characters, sanitizing...');
            const sanitized = aiResponse
              .replace(/[\u0000-\u0008\u000B-\u000C\u000E-\u001F\u007F-\u009F]/g, '')
              .replace(/\u2028/g, '\\n')
              .replace(/\u2029/g, '\\n\\n');
            if (sanitized !== aiResponse) {
              console.log('‚úÖ Response sanitized successfully');
              aiResponse = sanitized;
            }
          }
        }

        console.log('‚úÖ OpenAI response received:', aiResponse.substring(0, 100) + '...');

        // Add AI response to conversation
        conversation.messages.push({
          role: 'assistant',
          content: aiResponse
        });

      // Update conversation context
      this.conversations.set(conversationId, conversation);

      console.log('‚úÖ OpenAI response generated successfully');
      const responseData = {
        response: aiResponse,
        confidence: knowledgeResults.length > 0 ? 0.95 : 0.8, // Higher confidence with knowledge base
        source: knowledgeResults.length > 0 ? 'openai+kb' : 'openai',
        knowledgeUsed: knowledgeResults.length > 0,
        knowledgeSources: knowledgeResults.map(r => r.source),
        shouldEscalate: this.shouldEscalateToHuman(message, aiResponse)
      };
      
      console.log('üìà Response summary:', {
        source: responseData.source,
        knowledgeUsed: responseData.knowledgeUsed,
        knowledgeSources: responseData.knowledgeSources,
        confidence: responseData.confidence
      });
      
      return responseData;

    } catch (error) {
      console.error('‚ùå OpenAI API Error:', error);
      if (error.message?.includes('API key')) {
        console.error('üîë OpenAI API Key Error - check your key is valid');
      }
      return this.getFallbackResponse(message, conversationId);
    }
  }

  // Check if message should be handled by Multi-Store Shopify integration
  async checkShopifyIntegration(message, conversationId) {
    try {
      console.log('üè¢ Attempting Multi-Store Shopify integration check...');
      
      // Import the Multi-Store Shopify service
      const { multiStoreShopifyService } = await import('./integrations/multiStoreShopifyService.js');
      
      // Set organization context (use default for now, can be dynamic later)
      multiStoreShopifyService.setOrganization('00000000-0000-0000-0000-000000000001');
      
      // Validate and ensure Shopify connection with timeout
      const connectionTimeout = new Promise((resolve) => {
        setTimeout(() => resolve({ connected: false, timedOut: true }), 5000);
      });
      
      const connectionCheck = multiStoreShopifyService.isConnected()
        .then(connected => ({ connected, timedOut: false }))
        .catch(error => ({ connected: false, error }));
      
      const { connected, timedOut, error } = await Promise.race([connectionCheck, connectionTimeout]);
      
      if (timedOut) {
        console.log('‚ö†Ô∏è Shopify connection check timed out, skipping integration');
        return { hasShopifyResponse: false, error: 'Connection timeout' };
      }
      
      if (!connected) {
        console.log('‚ö†Ô∏è No Shopify stores connected, skipping integration');
        return { hasShopifyResponse: false, error: error?.message };
      }
      
      console.log('‚úÖ Multi-store Shopify connected, processing customer message...');
      
      // Get and validate customer data from conversation context
      const conversation = this.conversations.get(conversationId) || {};
      const customerData = this.validateCustomerData(conversation.customerData || {});
      
      // Process the message with Multi-Store Shopify service
      const result = await multiStoreShopifyService.processCustomerMessage(message, customerData);
      
      console.log('üìà Multi-store Shopify processing result:', {
        hasResponse: result.hasShopifyResponse,
        type: result.type,
        store: result.store,
        confidence: result.confidence
      });
      
      return result;
      
    } catch (error) {
      console.error('‚ùå Error in Multi-Store Shopify integration:', error);
      return { hasShopifyResponse: false, error: error.message };
    }
  }

  // Enhanced fallback response that can also search knowledge base
  getFallbackResponse(message, conversationId = null) {
    console.log('üîÑ Using fallback response for:', message);
    console.log('üîÑ Production mode active:', localStorage.getItem('PRODUCTION_MODE') === 'true');
    
    let knowledgeResults = [];
    
    // Try to search knowledge base even in fallback mode
    if (conversationId) {
      knowledgeResults = this.searchKnowledgeBase(conversationId, message, 1);
    }
    
    if (knowledgeResults.length > 0) {
      // Use knowledge base for fallback response
      const result = knowledgeResults[0];
      let response = "";
      
      // Extract a relevant snippet
      const snippet = result.content.substring(0, 200);
      response += snippet;
      
      if (result.content.length > 200) {
        response += "...";
      }
      
      console.log('‚úÖ Knowledge base fallback used');
      return {
        response,
        confidence: 0.7,
        source: 'knowledge_base',
        knowledgeUsed: true,
        knowledgeSources: [result.source],
        shouldEscalate: false
      };
    }

    // Improved context-aware fallback responses
    const responses = {
      greeting: [
        "Hello! I'm here to help you. What can I assist you with today?",
        "Hi there! How can I help you?",
        "Welcome! What questions do you have for me?"
      ],
      help: [
        "I'd be happy to help you with that. Can you provide more details?",
        "Let me assist you with that. What specific issue are you facing?",
        "I'm here to help! Could you tell me more about what you need?"
      ],
      order: [
        "I can help you with order-related questions. Could you provide your order number or more details?",
        "Let me help you track your order. Can you share your order number?",
        "I'm here to assist with your order. What specific information do you need?"
      ],
      product: [
        "I'd be happy to help you find the right product. What are you looking for?",
        "Let me help you with product information. What would you like to know?",
        "I can assist with product recommendations. What are your needs?"
      ],
      technical: [
        "I can help with technical issues. Can you describe what problem you're experiencing?",
        "Let me assist with that technical question. What specifically isn't working?",
        "I'm here to help troubleshoot. What issue are you having?"
      ],
      billing: [
        "I can help with billing questions. What do you need assistance with?",
        "Let me help with your billing inquiry. Can you provide more details?",
        "I'm here to assist with billing matters. What's your concern?"
      ],
      escalation: [
        "I understand this is important. Let me connect you with a human agent who can better assist you.",
        "For this type of request, I'll transfer you to one of our specialists.",
        "I think a human agent would be better suited to help you with this. Let me get someone for you."
      ],
      default: [
        "Thank you for your message. I'm here to help! Could you tell me more about what you need assistance with?",
        "I appreciate you reaching out. I'd like to help - can you provide more details about your question?",
        "I'm ready to assist you. What specific information or help are you looking for?"
      ]
    };

    // Smart keyword matching for better responses
    const lowerMessage = message.toLowerCase();
    let responseCategory = 'default';

    // Check for greetings
    if (lowerMessage.match(/\b(hello|hi|hey|good morning|good afternoon|good evening)\b/)) {
      responseCategory = 'greeting';
    }
    // Check for order-related queries
    else if (lowerMessage.match(/\b(order|track|tracking|shipped|delivery|status)\b/)) {
      responseCategory = 'order';
    }
    // Check for product queries
    else if (lowerMessage.match(/\b(product|item|buy|purchase|recommend|suggest)\b/)) {
      responseCategory = 'product';
    }
    // Check for technical issues
    else if (lowerMessage.match(/\b(broken|not working|error|problem|issue|bug|technical)\b/)) {
      responseCategory = 'technical';
    }
    // Check for billing
    else if (lowerMessage.match(/\b(billing|charge|payment|refund|money|cost|price)\b/)) {
      responseCategory = 'billing';
    }
    // Check for help requests
    else if (lowerMessage.match(/\b(help|support|assist|need)\b/)) {
      responseCategory = 'help';
    }
    // Check for escalation
    else if (lowerMessage.match(/\b(human|agent|person|representative|manager|speak to someone|talk to someone|real person)\b/)) {
      responseCategory = 'escalation';
    }

    const responseOptions = responses[responseCategory];
    const randomResponse = responseOptions[Math.floor(Math.random() * responseOptions.length)];

    console.log(`üìù Smart fallback response used (category: ${responseCategory})`);
    return {
      response: randomResponse,
      confidence: responseCategory === 'escalation' ? 0.9 : 0.6,
      source: 'smart_fallback',
      knowledgeUsed: false,
      shouldEscalate: responseCategory === 'escalation',
      category: responseCategory
    };
  }

  // Determine if conversation should be escalated to human
  shouldEscalateToHuman(userMessage, aiResponse) {
    const escalationKeywords = [
      'human', 'agent', 'person', 'representative', 'manager', 
      'speak to someone', 'talk to someone', 'real person',
      'urgent', 'complaint', 'angry', 'frustrated'
    ];

    const userLower = userMessage.toLowerCase();
    return escalationKeywords.some(keyword => userLower.includes(keyword));
  }

  // Update bot configuration
  updateBotConfig(conversationId, config) {
    let conversation = this.conversations.get(conversationId) || { messages: [] };
    conversation.systemPrompt = config.systemPrompt || this.defaultSystemPrompt;
    this.conversations.set(conversationId, conversation);
  }

  // FIXED: Diagnostic function to test OpenAI client initialization
  async diagnoseOpenAI() {
    console.log('üîç DIAGNOSING OPENAI CLIENT INITIALIZATION...');
    
    const results = {
      timestamp: new Date().toISOString(),
      steps: [],
      success: false,
      error: null
    };
    
    try {
      // Step 1: Check API key
      const apiKey = import.meta.env.VITE_OPENAI_API_KEY;
      const keyStep = {
        step: 'API Key Check',
        success: !!apiKey && apiKey !== 'demo-mode' && apiKey.startsWith('sk-'),
        details: {
          hasKey: !!apiKey,
          keyLength: apiKey?.length || 0,
          validFormat: apiKey?.startsWith('sk-') || false,
          isDemoMode: apiKey === 'demo-mode'
        }
      };
      results.steps.push(keyStep);
      
      if (!keyStep.success) {
        results.error = 'Invalid or missing API key';
        return results;
      }
      
      // Step 2: Test async import
      const importStep = { step: 'Module Import', success: false, details: {} };
      try {
        const openaiModule = await import('openai');
        importStep.success = true;
        importStep.details = {
          hasDefault: !!openaiModule.default,
          hasNamedExport: !!openaiModule.OpenAI,
          moduleKeys: Object.keys(openaiModule)
        };
      } catch (error) {
        importStep.error = error.message;
      }
      results.steps.push(importStep);
      
      if (!importStep.success) {
        results.error = 'Module import failed';
        return results;
      }
      
      // Step 3: Test client creation
      const clientStep = { step: 'Client Creation', success: false, details: {} };
      try {
        // Clear any existing client to force fresh creation
        this.openaiClient = null;
        const client = await this.getOpenAIClient();
        
        clientStep.success = !!client;
        clientStep.details = {
          clientExists: !!client,
          hasChatMethod: !!client?.chat?.completions?.create,
          isCached: this.openaiClient === client
        };
      } catch (error) {
        clientStep.error = error.message;
      }
      results.steps.push(clientStep);
      
      if (!clientStep.success) {
        results.error = 'Client creation failed';
        return results;
      }
      
      // Step 4: Test simple API call (optional - may fail due to CORS)
      const apiStep = { step: 'API Test', success: false, details: {}, optional: true };
      try {
        const testResponse = await this.generateResponse('Test message', 'diagnostic-test');
        apiStep.success = !!testResponse?.response;
        apiStep.details = {
          gotResponse: !!testResponse,
          source: testResponse?.source || 'unknown'
        };
      } catch (error) {
        apiStep.error = error.message;
        apiStep.details.note = 'API test may fail due to CORS in browser - this is normal';
      }
      results.steps.push(apiStep);
      
      // Overall success if key steps passed
      results.success = results.steps.slice(0, 3).every(step => step.success);
      
    } catch (error) {
      results.error = error.message;
    }
    
    console.log('üîç DIAGNOSIS COMPLETE:', results);
    return results;
  }
  
  // Set up default knowledge base for testing
  initializeDefaultKnowledge() {
    const defaultKnowledge = [
      {
        id: 'kb_business_hours',
        name: 'Business Hours',
        type: 'faq',
        enabled: true,
        content: 'Our customer support is available Monday through Friday from 9 AM to 6 PM EST. We are closed on weekends and major holidays. For urgent matters outside business hours, please email support@company.com.',
        keywords: ['hours', 'time', 'open', 'closed', 'business', 'when', 'schedule']
      },
      {
        id: 'kb_contact_info',
        name: 'Contact Information',
        type: 'faq',
        enabled: true,
        content: 'You can contact us through this chat, email us at support@company.com, or call us at (555) 123-4567 during business hours. For billing questions, use billing@company.com.',
        keywords: ['contact', 'phone', 'email', 'support', 'help', 'reach']
      },
      {
        id: 'kb_shipping',
        name: 'Shipping Information',
        type: 'faq',
        enabled: true,
        content: 'We offer free standard shipping on orders over $50. Standard shipping takes 3-5 business days. Express shipping is available for $15 and takes 1-2 business days. International shipping is available to most countries.',
        keywords: ['shipping', 'delivery', 'ship', 'send', 'mail', 'fast', 'express', 'international']
      },
      {
        id: 'kb_returns',
        name: 'Return Policy',
        type: 'faq',
        enabled: true,
        content: 'We accept returns within 30 days of purchase. Items must be in original condition with tags attached. To start a return, email us with your order number. We provide prepaid return labels for your convenience.',
        keywords: ['return', 'refund', 'exchange', 'policy', 'money back', 'warranty']
      }
    ];

    // Set knowledge base for demo conversations
    const demoConversations = ['conv_demo_1', 'conv_demo_2', 'conv_demo_3', 'demo-conv-1', 'demo-conv-2', 'demo-conv-3'];
    demoConversations.forEach(convId => {
      this.setKnowledgeBase(convId, defaultKnowledge);
    });

    console.log('üìö Default knowledge base initialized for demo conversations');
  }

  // Clear conversation context
  clearConversation(conversationId) {
    this.conversations.delete(conversationId);
  }

  // Get conversation context
  getConversationContext(conversationId) {
    return this.conversations.get(conversationId) || { messages: [] };
  }
}

}

// Create singleton instance
const service = new ChatBotService();

// Add diagnostic functions in browser environment
if (typeof window !== 'undefined') {
  // Add global error handler to catch uncaught promise rejections
  window.addEventListener('unhandledrejection', function(event) {
    console.error('‚ùå Unhandled Promise Rejection:', event.reason);
    if (event.reason instanceof SyntaxError && event.reason.message.includes('JSON')) {
      console.log('üìù JSON Parse Error Details:', {
        message: event.reason.message,
        stack: event.reason.stack
      });
    }
  });

  // Add safe diagnostic function
  window.diagnoseOpenAI = async () => {
    try {
      return await service.diagnoseOpenAI();
    } catch (error) {
      console.error('Diagnostic error:', error);
      return { success: false, error: error.message };
    }
  };
  
  // Add safe test function
  window.testChatBot = async (message = 'Hello, test message') => {
    try {
      if (!message || typeof message !== 'string') {
        throw new ValidationError('Invalid message format');
      }
      return await service.generateResponse(message, 'browser-test');
    } catch (error) {
      console.error('Test error:', error);
      return { success: false, error: error.message };
    }
  };
}

// Export both default and named exports
export const chatBotService = service;
export default service;
